//Deeper thoughts
10--dp处理匹配，好！
18--do it with dfs to handle k-sum?
22--recursion，nice！
24--pointer to pointer
25--虽然过程类似，但递归也是个不错的方法/也用二级指针试试？
26--利用不对称区间的性质！
27--在同一序列上也可以同时进行两个不同的操作顺序，只要两者速度不同不导致重叠即可
30--在match失败时充分利用已有信息

//Notes
1. Two Sum--注意顺序，防止a=b的情况，用hash来找counterpart
2. Add Two Numbers--常规的链表操作， 写法类似归并
3. Longest Substring Without Repeating Characters--hash思维！！！，简单而快速找到下一步的开始点，初始化值的选择
4. Median of Two Sorted Arrays--关键是对k做二分，每次去掉一般左右的元素，注意递归的corner case
5. Longest Palindromic Substring--从中点考虑，向两边寻找，注意边界和重复元素
6. ZigZag Conversion--模拟，每numRows-1个元素转弯，注意corner case：其一是只有一行，其二是输入为空串
7. Reverse Integer--注意整型正负极值的范围不同
8. String to Integer (atoi)--先去掉空格，再判断符号，注意处理越界
9. Palindrome Number--通用的方法，从两边同步判断，注意终止条件，用除法来取最高位
10. Regular Expression Matching--关键是处理‘*’，可以用递归，也可以用dp，nice problem！
11. Container With Most Water--分析当长度减少后该移动哪边，移动长的一边没任何卵用，移动短的一边或许还有希望
12. Integer to Roman--hash！！！
13. Roman to Integer--以5、50、500为分界判断
14. Longest Common Prefix--too naive
15. 3Sum--排序+两指针，O(N^2)，貌似没别的好方法了，注意在移动左右游标时的边界，在符合情况要去到重复时首先要离开自身
16. 3Sum Closest--还是两指针
17. Letter Combinations of a Phone Number--典型的dfs，加上再减去，维持一个当前结果
18. 4Sum--基本思路还是两指针，但是要注意剪枝!!!另外还要注意去重。
19. Remove Nth Node From End of List--仔细
20. Valid Parentheses--注意检查是否为空
21. Merge Two Sorted Lists--和归并排序一样的写法，自动包含了所有的corner case
22. Generate Parentheses--多路dfs，在每个位置根据剩余的量分配左括号或右括号
23. Merge k Sorted Lists--用priority_queue来优化
24. Swap Nodes in Pairs--二级指针！好！
25. Reverse Nodes in k-Group--推广，一般化的想法是逐步反转K个节点
26. Remove Duplicates from Sorted Array--从反面想，计数重复的，利用不对称区间的性质，好！不要用傻逼的erase
27. Remove Element--将两种操作序列分开！
28. Implement strStr()--KMP,brute-force is trival,注意next[k-1]的意义及两重等效意义
29. Divide Two Integers---转换成二进制乘幂表达，二分法，注意移位时可能越界
30. Substring with Concatenation of All Words--字符串比对，在不match时尽量利用已有信息，而不是简单丢弃重来，注意validCnt的意义与增减
